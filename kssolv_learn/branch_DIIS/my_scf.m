function [mol,H,X,info] = my_scf(mol,options)
% SCF Self Consistent Field iteration.
%    [mol,H,X,info] = SCF(mol,options) adopts Self Consistent Field (SCF)
%    iteration to find the ground state minimum total energy and the
%    corresponding wave functions. mol is a Molecule object and options is
%    the options for running the SCF. Please read setksopt for detailed
%    information about options. SCF returns the molecule mol with/without
%    force, the Hamiltonian H, the wave functions X, and the information
%    for each iteration in info. If a crystal object is input instead of
%    molecule, the results will be generated by scf4c. If a molecule object
%    with non-zero temperature is input, the results will be generated by
%    scf4m.
%
%   See also scf4m, scf4c, dcm, trdcm.

%  Copyright (c) 2016-2017 Yingzhou Li and Chao Yang,
%                          Stanford University and Lawrence Berkeley
%                          National Laboratory
%  This file is distributed under the terms of the MIT License.

if (nargin < 2)
    options = setksopt();
end

%mol.nel = sum(mol.natoms.*[mol.ppvar.venums]);

print_scf_info(mol,options);

% Set timer
tic;

maxPhiIter = options.maxphiiter;
phiTol = options.phitol;

% Regular SCF Iteration
ishybrid = strcmp(mol.funct,'HSE06');
if ishybrid
  fprintf('Regular hybrid SCF for Initialization\n');
  funct = mol.funct;
  mol.funct='PBE';
else
  fprintf('Regular SCF for Pure DFT\n');
end
%第一次的PBE
[mol,H,X,info] = scf0(mol,options);

if ishybrid
  mol.funct = funct;
else
  return
end

% Hybrid Nested Iterations
Vexx = getVexx(X, mol, options.dfrank);
if options.useace
    Vexx = calculateACE(Vexx, X);
end
fock0 = getExx(X, Vexx, mol);
options.ishybrid = 1;

fprintf('Beging Hybrid SCF calculation for %s...\n',mol.name);
for iterphi = 1:maxPhiIter
    fprintf('Phi iter %3d:\n', iterphi);
    options.X0 = X;
    options.rho0 = H.rho;
    options.Vexx = Vexx;
    [mol,H,X,info] = scf0(mol, options);
    fock1 = getExx(X, Vexx, mol);
    Vexx = getVexx(X, mol, options.dfrank);
    if options.useace
        Vexx = calculateACE(Vexx, X);
    end
    fock2 = getExx(X, Vexx, mol);
    dfock = abs(2*fock1-fock0-fock2);
    fock0 = fock2;
    fprintf('Etot              = %20.13e\n', info.Etot+fock2);
    fprintf('Fock Energy       = %20.13e\n', fock2);
    fprintf('dfock             = %20.13e\n', dfock);
    if (dfock < phiTol)
        break
    end  
end

info.Etotwf = info.Etot + fock2;
info.Efock  = fock2;

timetot = toc;
fprintf('Etot        = %20.13e\n', info.Etot+fock2);
fprintf('Etot(Ry)    = %20.13e\n', (info.Etot+fock2)*2);
fprintf('Efock       = %20.13e\n', fock2);
fprintf('Total time  = %20.13e\n', timetot);

end

%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%
function [mol,H,X,info] = scf0(mol,options)
% SCF Self Consistent Field iteration.
%    [mol,H,X,info] = SCF(mol,options) adopts Self Consistent Field (SCF)
%    iteration to find the ground state minimum total energy and the
%    corresponding wave functions. mol is a Molecule object and options is
%    the options for running the SCF. Please read setksopt for detailed
%    information about options. SCF returns the molecule mol with/without
%    force, the Hamiltonian H, the wave functions X, and the information
%    for each iteration in info. If a crystal object is input instead of
%    molecule, the results will be generated by scf4c. If a molecule object
%    with non-zero temperature is input, the results will be generated by
%    scf4m.
%
%   See also scf4m, scf4c, dcm, trdcm.

%  Copyright (c) 2016-2017 Yingzhou Li and Chao Yang,
%                          Stanford University and Lawrence Berkeley
%                          National Laboratory
%  This file is distributed under the terms of the MIT License.
if (nargin < 2)
    options = setksopt();
end

if isa(mol,'Crystal')
    [mol,H,X,info] = scf4c(mol,options);
    return;
elseif mol.temperature > 0
    [mol,H,X,info] = scf4m(mol,options);
    return;
end

% Set timer
tstart  = cputime;

% Initialize input variables
verbose    = ~strcmpi(options.verbose,'off');
force      = options.force;
maxscfiter = options.maxscfiter;
scftol     = options.scftol;
what2mix   = options.what2mix;
mixtype    = options.mixtype;
mixdim     = options.mixdim;
betamix    = options.betamix;
brank      = options.brank;
X          = options.X0;
rho        = options.rho0;
ishybrid   = options.ishybrid;
Vexx       = options.Vexx;
ngbands    = options.ngbands;
ncbands    = options.ncbands+ngbands;
ncbands    = options.ncbands;

%options.cgtol = 5e-3;

nspin      = mol.nspin;

% Initialize Hamiltonian, Wavefun, and Preconditioners
[mol,H,X,Hprec,nocc] = iterinit(mol,rho,X,ncbands);
X.occ = zeros(1,ncols(X));
X.occ(1:nocc) = 1;

% calculate Ewald and Ealphat
Eewald     = getEewald(mol);
Ealphat    = getEalphat(mol);

vion       = H.vion;
vext       = H.vext;
vtot       = H.vtot;
rho        = H.rho;
H.ishybrid = ishybrid;
H.vexx     = Vexx;
H.eband    = zeros(ncols(X),1);

% Initialize output variables
Etotvec    = zeros(maxscfiter,1);
scferr     = zeros(maxscfiter,1);
dfmat      = [];
dvmat      = [];
cdfmat     = [];

vhart = getVhart(mol,rho);
Ecoul_old = getEcoul(mol,abs(rho),vhart);
fprintf('Beging SCF calculation for %s...\n',mol.name);
for iterscf = 1:maxscfiter
    
    rhoin  = rho;
    vtotin = vtot;

    % Diagonalization
    [X, ev] = updateX(mol, H, X, Hprec, options);
    X.occ = zeros(1,ncols(X));
    X.occ(1:nocc) = 1;
    H.eband = ev;
    
    % Update density rho
    rho = getcharge(mol,X,nocc);
    H.rho = rho;

    % Mixing with density
    if strcmpi(what2mix,'rho')
        rhoerr = norm(rho(:)-rhoin(:))/norm(rhoin(:));
        scferr(iterscf) = rhoerr;
        %fprintf('Rel Rho Err     = %20.3e\n',rhoerr);
        [rho,dfmat,dvmat,cdfmat] = potmixing(mol,rhoin,rho,...
            iterscf,mixtype, betamix, ...
            dfmat, dvmat, cdfmat, mixdim, ...
            brank);
    end
    
    % Kinetic energy and some additional energy terms
    Ekin = (2/nspin)*sum(ev(1:nocc));
    % ionic and external potential energy was included in Ekin
    % along with incorrect Ecoul and Exc. Need to correct them
    % later;
    Ecor = getEcor(mol, rho, vtot, vion, vext);
    
    % Compute Hartree and exchange correlation energy and potential
    % using the new charge density; update the total potential
    [vhart,vxc,uxc2,rho,uxcsr]=getVhxc(mol,rho);
    
    % Update total potential
    vtot = getVtot(mol, vion, vext, vhart, vxc);
    if strcmpi(what2mix,'pot')
        vtoterr = norm(vtot(:)-vtotin(:))/norm(vtotin(:));
        scferr(iterscf) = vtoterr;
        %fprintf('Rel Vtot Err    = %20.3e\n',vtoterr);
        [vtot,dfmat,dvmat,cdfmat] = ...
            potmixing(mol,vtotin,vtot,iterscf,mixtype,...
            betamix,dfmat,dvmat,cdfmat,mixdim,brank);
    end
    H.vtot = vtot;
    
    % Calculate the potential energy based on the new potential
    Ecoul = getEcoul(mol,abs(rho),vhart);
    Evxc  = getEcoul(mol,abs(rho),vxc);
    Exc   = getExc(mol,abs(rho),uxc2,uxcsr);
    if ishybrid
      Exx   = getExx(X,Vexx,mol);
    else
      Exx   = 0;
    end
    Etot  = Eewald + Ealphat + Ekin + Ecor + Ecoul + Exc - 2*Exx;
    %Eewald , Ealphat , Ekin , Ecor , Ecoul , Exc , 2*Exx
    Etotvec(iterscf) = Etot;
    
    % Convergence check
    fprintf('Iter=%3d:: Energy=%10.8e, Error=%10.8e\n',iterscf,Etot,scferr(iterscf));
    [cvg,resfro] = reportconverge(H,X,iterscf,maxscfiter, ...
        scferr(iterscf),scftol,verbose);
    %if cvg && iterscf > 3
    if cvg
        info.converge = true;
        break;
    end
    deltaE = abs(Ecoul - Ecoul_old);
    Ecoul_old = Ecoul;
    options.cgtol = min(options.cgtol,0.1*deltaE/max(1.0,nocc));
    options.cgtol = max(options.cgtol,1e-10);
end

%ncol = ncols(X);
%X.occ = zeros(1,ncol)
%X.occ(:,1:ncol) = 1;
%ev(ncol-ngbands+1:ncol) = [];

if force
    mol.xyzforce = getFtot(mol,H,X,rho);
end

info.Eigvals = ev;
info.Etotvec = Etotvec(1:iterscf);
info.SCFerrvec = scferr(1:iterscf);
info.Etot = Etot;

timetot = cputime - tstart;
fprintf('Etot            = %20.13e\n', Etot);
fprintf('Etot(Ry)        = %20.13e\n', Etot*2);
fprintf('Eone-electron   = %20.13e\n', Ekin+Ecor);
fprintf('Ehartree        = %20.13e\n', Ecoul);
fprintf('Exc             = %20.13e\n', Exc);
fprintf('Eewald          = %20.13e\n', Eewald);
fprintf('Ealphat         = %20.13e\n', Ealphat);
fprintf('--------------------------------------\n');
fprintf('Total time used = %20.3e\n', timetot);
fprintf('||HX-XD||_F     = %20.3e\n', resfro);

end


function print_scf_info(mol, options)

grid = Ggrid(mol);
fprintf('unit-cell volume          =%15.4f  (a.u.)^3\n',mol.vol);
fprintf('number of atoms/cell      =%15d\n',sum(mol.natoms));
fprintf('number of electrons       =%15d\n',mol.nel);
fprintf('kinetic-energy cutoff     =%15.4f Hartree\n',mol.ecut);
fprintf('mixing beta               =%15.4f\n',options.betamix);
fprintf('mixing type               =%15s\n',options.mixtype);
fprintf('exchange correlation      =%15s\n',mol.funct);
fprintf('real space grid           =(%4d,%4d,%4d)\n',mol.n1,mol.n2,mol.n3);
fprintf('reciprocal space grid     =%8d\n',grid.ng);

end
